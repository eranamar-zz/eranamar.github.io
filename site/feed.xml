<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="http://jekyllrb.com" version="3.4.2">Jekyll</generator><link href="https://eranamar.github.io/site/feed.xml" rel="self" type="application/atom+xml" /><link href="https://eranamar.github.io/site/" rel="alternate" type="text/html" /><updated>2017-03-30T17:56:18+03:00</updated><id>https://eranamar.github.io/site/</id><title type="html">Theory Lunch</title><subtitle>Computer Science topics over lunch</subtitle><author><name>Eran Amar, Yosef Pogrow, Ron Shiff</name></author><entry><title type="html">Derandomization for Pairwise Independent Seed</title><link href="https://eranamar.github.io/site/2017/03/30/Derandomization-for-Pairwise-Independent-Seed.html" rel="alternate" type="text/html" title="Derandomization for Pairwise Independent Seed" /><published>2017-03-30T00:00:00+03:00</published><updated>2017-03-30T00:00:00+03:00</updated><id>https://eranamar.github.io/site/2017/03/30/Derandomization-for-Pairwise-Independent-Seed</id><content type="html" xml:base="https://eranamar.github.io/site/2017/03/30/Derandomization-for-Pairwise-Independent-Seed.html">&lt;script type=&quot;math/tex&quot;&gt;
\newcommand{\lyxlock}{}
&lt;/script&gt;

&lt;noscript&gt;
&lt;div class=&quot;warning&quot;&gt;
Warning: &lt;a href=&quot;http://www.mathjax.org/&quot;&gt;MathJax&lt;/a&gt; requires JavaScript to correctly process the mathematics on this page. Please enable JavaScript on your browser.
&lt;/div&gt;&lt;hr /&gt;
&amp;lt;/hr&amp;gt;&lt;/noscript&gt;

&lt;h1 class=&quot;Section&quot;&gt;
&lt;a class=&quot;toc&quot; name=&quot;toc-Section-1&quot;&gt;1&lt;/a&gt; Randomized Algorithm Settings
&lt;/h1&gt;
&lt;div class=&quot;Unindented&quot;&gt;
Randomized algorithm is an algorithm that in addition to its input also uses internally &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
t
&lt;/script&gt;
&lt;/span&gt; coin-tosses (i.e. random bits) in order to decide on its output, so different invocations of the algorithm with the same input may yield different outputs that depends on the results of the coins. One can think about the internal coin-tosses as a binary string &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
r
&lt;/script&gt;
&lt;/span&gt; of length &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
t
&lt;/script&gt;
&lt;/span&gt; that is being fixed before the algorithm starts, a.k.a &lt;i&gt;seed&lt;/i&gt;, and the randomness now comes from choosing different string for each invocation. 
&lt;/div&gt;
&lt;div class=&quot;Indented&quot;&gt;
Note that tossing &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
t
&lt;/script&gt;
&lt;/span&gt; fair coins, is exactly like drawing a random string &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
r
&lt;/script&gt;
&lt;/span&gt; from the set &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\left\{ 0,1\right\} ^{t}
&lt;/script&gt;
&lt;/span&gt; where all candidates have equal probability (i.e. each has a probability of &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
2^{-t}
&lt;/script&gt;
&lt;/span&gt;).
&lt;/div&gt;
&lt;div class=&quot;Indented&quot;&gt;
Say we have a randomize algorithm &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
A
&lt;/script&gt;
&lt;/span&gt; for some problem that we would like to solve. We have a guarantee that for any input &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
x
&lt;/script&gt;
&lt;/span&gt; of length &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
n
&lt;/script&gt;
&lt;/span&gt;, algorithm &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
A
&lt;/script&gt;
&lt;/span&gt; runs in &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
poly\left(n\right)
&lt;/script&gt;
&lt;/span&gt;, and outputs either a valid solution &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
S
&lt;/script&gt;
&lt;/span&gt; if it succeeds or output &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
failed
&lt;/script&gt;
&lt;/span&gt;. The success probability of the algorithm is &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
p
&lt;/script&gt;
&lt;/span&gt; (which may be even infinitesimally small). 
&lt;/div&gt;
&lt;div class=&quot;Indented&quot;&gt;
The first question to ask is, &lt;i&gt;can we convert the randomized algorithm into a deterministic one?&lt;/i&gt;
&lt;/div&gt;
&lt;h1 class=&quot;Section&quot;&gt;
&lt;a class=&quot;toc&quot; name=&quot;toc-Section-2&quot;&gt;2&lt;/a&gt; Brute Force Derandomization
&lt;/h1&gt;
&lt;div class=&quot;Unindented&quot;&gt;
The answer is&lt;i&gt; yes&lt;/i&gt;, and there is a simple way to do that: Upon receiving an input &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
x
&lt;/script&gt;
&lt;/span&gt;, iterate over all possible strings &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
r\in\left\{ 0,1\right\} ^{t}
&lt;/script&gt;
&lt;/span&gt; and run &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
A_{r}\left(x\right)
&lt;/script&gt;
&lt;/span&gt;. That is, simulate &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
A
&lt;/script&gt;
&lt;/span&gt; on &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
x
&lt;/script&gt;
&lt;/span&gt; with &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
r
&lt;/script&gt;
&lt;/span&gt; as the random seed. Return the first solution that &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
A
&lt;/script&gt;
&lt;/span&gt; outputs (i.e. anything that is not &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
failed
&lt;/script&gt;
&lt;/span&gt;).
&lt;/div&gt;
&lt;div class=&quot;Indented&quot;&gt;
The idea behind this method is that if there is a non-zero probability for &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
A
&lt;/script&gt;
&lt;/span&gt; to output a valid solution for the input &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
x
&lt;/script&gt;
&lt;/span&gt;, then there must be a random seed that leads to that output when executing algorithm &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
A
&lt;/script&gt;
&lt;/span&gt; on &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
x
&lt;/script&gt;
&lt;/span&gt;. So all we need to do is iterating over all possible seeds of length &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
t
&lt;/script&gt;
&lt;/span&gt;, and that leads to a deterministic algorithm. 
&lt;/div&gt;
&lt;div class=&quot;Indented&quot;&gt;
You probably already see the problem here. If &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
t=\mathcal{O}\left(n\right)
&lt;/script&gt;
&lt;/span&gt; then the running time of the deterministic procedure is &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
2^{\mathcal{O}\left(t\right)}poly\left(n\right)
&lt;/script&gt;
&lt;/span&gt;.
&lt;/div&gt;
&lt;div class=&quot;Indented&quot;&gt;
Terrible, terrible running time.
&lt;/div&gt;
&lt;div class=&quot;Indented&quot;&gt;
On the other hand, if &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
t
&lt;/script&gt;
&lt;/span&gt; is a constant or even up to &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\mathcal{O}\left(\log n\right)
&lt;/script&gt;
&lt;/span&gt;, then the resulting running time will stay polynomial, and everybody is happy. In the next section we will see that with an additional assumption, we can “decrease” the seed length from &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
n
&lt;/script&gt;
&lt;/span&gt; to &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\log n
&lt;/script&gt;
&lt;/span&gt; bits.
&lt;/div&gt;
&lt;h1 class=&quot;Section&quot;&gt;
&lt;a class=&quot;toc&quot; name=&quot;toc-Section-3&quot;&gt;3&lt;/a&gt; Pairwise Independent Seed
&lt;/h1&gt;
&lt;div class=&quot;Unindented&quot;&gt;
We start off with a definition.
&lt;/div&gt;
&lt;div class=&quot;Definition&quot;&gt;
&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
k
&lt;/script&gt;
&lt;/span&gt;-wise Independent Family. Let &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\mathcal{X}
&lt;/script&gt;
&lt;/span&gt; be a set of random variables. We say that &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\mathcal{X}
&lt;/script&gt;
&lt;/span&gt; is a &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
k
&lt;/script&gt;
&lt;/span&gt;-wise independent family if for any subset of &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
k
&lt;/script&gt;
&lt;/span&gt; variables &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
X_{1},..,X_{k}\in\mathcal{X}
&lt;/script&gt;
&lt;/span&gt;, and values &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
y_{1},...,y_{k}
&lt;/script&gt;
&lt;/span&gt; &lt;span class=&quot;MathJax_Preview&quot;&gt;
&lt;script type=&quot;math/tex;mode=display&quot;&gt;

\mathbf{P}\left[\bigwedge_{i\in I}X_{i}=y_{i}\right]=\prod_{i\in I}\mathbf{P}\left[X_{i}=y_{i}\right]\qquad\forall I\subseteq\left[k\right]

&lt;/script&gt;
&lt;/span&gt;
that is, any subset of &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
k
&lt;/script&gt;
&lt;/span&gt; random variables from &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\mathcal{X}
&lt;/script&gt;
&lt;/span&gt; are fully independent. The family &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\mathcal{X}
&lt;/script&gt;
&lt;/span&gt; is called pairwise independent family when &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
k=2
&lt;/script&gt;
&lt;/span&gt;.
&lt;/div&gt;
&lt;div class=&quot;Unindented&quot;&gt;

&lt;/div&gt;
&lt;div class=&quot;Indented&quot;&gt;
What this definition have with our settings? observe that up until now we implicitly assumed that the algorithm needs its coins to be fully independent. That is, if we think of &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
s
&lt;/script&gt;
&lt;/span&gt; as a series of Bernoulli r.vs then we actually required &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
s
&lt;/script&gt;
&lt;/span&gt; to be &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
t
&lt;/script&gt;
&lt;/span&gt;-wise independent family, which is much stronger property than pairwise independence. If we relax that requirement and assume that the algorithm only needs its coins to be pairwise independent, then there is a way (described in next section) to construct &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
n
&lt;/script&gt;
&lt;/span&gt; &lt;i&gt;pairwise independent&lt;/i&gt; bits using only &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\mathcal{O}\left(\log n\right)
&lt;/script&gt;
&lt;/span&gt; &lt;i&gt;fully independent&lt;/i&gt; bits. That construction can be “embedded” into our algorithm such that we ultimately ends up with a procedure that only requires &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\mathcal{O}\left(\log n\right)
&lt;/script&gt;
&lt;/span&gt; fully independent seed. Applying the derandomization method from previous section will result with a deterministic algorithm that will still run in &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
poly\left(n\right)
&lt;/script&gt;
&lt;/span&gt; time.
&lt;/div&gt;
&lt;div class=&quot;Indented&quot;&gt;
Of course, we may assume pairwise independent only if it won’t break the correctness analysis of the randomized algorithm that we want to derandomize.
&lt;/div&gt;
&lt;h1 class=&quot;Section&quot;&gt;
&lt;a class=&quot;toc&quot; name=&quot;toc-Section-4&quot;&gt;4&lt;/a&gt; Stretching the Seed
&lt;/h1&gt;
&lt;div class=&quot;Unindented&quot;&gt;
Suppose we have &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\approx\log n
&lt;/script&gt;
&lt;/span&gt; fair fully independent coins, we want to construct a method to generate from them &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\approx n
&lt;/script&gt;
&lt;/span&gt; fair pairwise independent bits. The following claim shows such construction.
&lt;/div&gt;
&lt;div class=&quot;Claim&quot;&gt;
Suppose we have &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
t:=\log\left(n\right)+1
&lt;/script&gt;
&lt;/span&gt; fully independent Bernoulli random variables, each with probability &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\frac{1}{2}
&lt;/script&gt;
&lt;/span&gt;. Fix them is some arbitrary order to get a (random) vector &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\mathbf{s}
&lt;/script&gt;
&lt;/span&gt; of length &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
t
&lt;/script&gt;
&lt;/span&gt;. Let &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\mathcal{S}=\left\{ \left\langle \mathbf{s},\mathbf{x}\right\rangle _{mod2}\mid\mathbf{x}\in\left\{ 0,1\right\} ^{t},\:\:x\ne\mathbf{0}\right\} 
&lt;/script&gt;
&lt;/span&gt; be the set of all possible sums modulo 2 of those r.vs and note that &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\left|\mathcal{S}\right|=2^{t}-1=\Theta\left(n\right)
&lt;/script&gt;
&lt;/span&gt;, then &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\mathcal{S}
&lt;/script&gt;
&lt;/span&gt; is a family of pairwise independent bits.
&lt;/div&gt;
&lt;div class=&quot;Unindented&quot;&gt;
To prove that we start with a very basic lemma.
&lt;/div&gt;
&lt;div class=&quot;Lemma&quot;&gt;
Let &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
X,Y\sim Bernoulli\left(0.5\right)
&lt;/script&gt;
&lt;/span&gt; be two independent random variables, let &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
Z=X+Y
&lt;/script&gt;
&lt;/span&gt; then &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
Z\sim Bernoulli\left(0.5\right)
&lt;/script&gt;
&lt;/span&gt;. Moreover, &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
Z
&lt;/script&gt;
&lt;/span&gt; is independent from &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
X
&lt;/script&gt;
&lt;/span&gt; and from &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
Y
&lt;/script&gt;
&lt;/span&gt;.
&lt;/div&gt;
&lt;div class=&quot;Proof&quot;&gt;
For any &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
b\in\left\{ 0,1\right\} 
&lt;/script&gt;
&lt;/span&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;
&lt;script type=&quot;math/tex;mode=display&quot;&gt;
\begin{align*}
\mathbf{P}\left[X+Y=b\right] &amp; =\mathbf{P}\left[X=1,Y=1-b\right]+\mathbf{P}\left[X=0,Y=b\right]\\
 &amp; =\mathbf{P}\left[X=1\right]\mathbf{P}\left[Y=1-b\right]+\mathbf{P}\left[X=0\right]\mathbf{P}\left[Y=b\right]\\
 &amp; =\frac{1}{2}\left(\mathbf{P}\left[Y=1-b\right]+\mathbf{P}\left[Y=1-b\right]\right)\\
 &amp; =\frac{1}{2}
\end{align*}
&lt;/script&gt;
&lt;/span&gt;
thus &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
Z\sim Bernoulli\left(0.5\right)
&lt;/script&gt;
&lt;/span&gt;. Next w.l.o.g we prove that &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
Z
&lt;/script&gt;
&lt;/span&gt; independent from &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
X
&lt;/script&gt;
&lt;/span&gt;. Take any &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
b_{1},b_{2}\in\left\{ 0,1\right\} 
&lt;/script&gt;
&lt;/span&gt;. If &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
b_{1}=b_{2}
&lt;/script&gt;
&lt;/span&gt; then &lt;span class=&quot;MathJax_Preview&quot;&gt;
&lt;script type=&quot;math/tex;mode=display&quot;&gt;
\begin{align*}
\mathbf{P}\left[X=b_{1},Z=b_{2}\right] &amp; =\mathbf{P}\left[X=b_{1},X+Y=b_{1}\right]\\
 &amp; =\mathbf{P}\left[X=b_{1},Y=0\right]\\
 &amp; =\mathbf{P}\left[X=b_{1}\right]\mathbf{P}\left[Y=0\right]\\
 &amp; =\mathbf{P}\left[X=b_{1}\right]\cdot\frac{1}{2}\\
 &amp; =\mathbf{P}\left[X=b_{1}\right]\mathbf{P}\left[Z=b_{1}\right]
\end{align*}
&lt;/script&gt;
&lt;/span&gt;
and we done. And if &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
b_{2}=1-b_{1}
&lt;/script&gt;
&lt;/span&gt; then very similarly we get&lt;span class=&quot;MathJax_Preview&quot;&gt;
&lt;script type=&quot;math/tex;mode=display&quot;&gt;
\begin{align*}
\mathbf{P}\left[X=b_{1},Z=b_{2}\right] &amp; =\mathbf{P}\left[X=b_{1},X+Y=1-b_{1}\right]\\
 &amp; =\mathbf{P}\left[X=b_{1},Y=1\right]\\
 &amp; =\mathbf{P}\left[X=b_{1}\right]\mathbf{P}\left[Z=b_{1}\right]
\end{align*}
&lt;/script&gt;
&lt;/span&gt;
which conclude the proof.
&lt;/div&gt;
&lt;div class=&quot;Unindented&quot;&gt;
Now we prove the claim from above.
&lt;/div&gt;
&lt;div class=&quot;Proof&quot;&gt;
Take two different variables &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
X_{1}=\left\langle \mathbf{s},\mathbf{x}_{1}\right\rangle \in\mathcal{S}
&lt;/script&gt;
&lt;/span&gt; and &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
X_{2}=\left\langle \mathbf{s},\mathbf{x}_{2}\right\rangle \in\mathcal{S}
&lt;/script&gt;
&lt;/span&gt;, and let &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
b_{1},b_{2}\in\left\{ 0,1\right\} 
&lt;/script&gt;
&lt;/span&gt; (all the operations in the proof are &lt;b&gt;modulo 2&lt;/b&gt;). Obviously, we only care about the set of indices which are non-zero in the vectors &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\mathbf{x}_{1}
&lt;/script&gt;
&lt;/span&gt; and &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\mathbf{x}_{2}
&lt;/script&gt;
&lt;/span&gt;. Let these sets be &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
I_{1},I_{2}
&lt;/script&gt;
&lt;/span&gt; respectively. Denote &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
M_{0}=\sum_{i\in I_{1}\cap I_{2}}\mathbf{s}_{i}
&lt;/script&gt;
&lt;/span&gt;, &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
M_{1}=\sum_{i\in I_{1}\backslash I_{2}}\mathbf{s}_{i}
&lt;/script&gt;
&lt;/span&gt; and &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
M_{2}=\sum_{i\in I_{2}\backslash I_{1}}\mathbf{s}_{i}
&lt;/script&gt;
&lt;/span&gt; where summation over empty set is defined as the constant &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
0
&lt;/script&gt;
&lt;/span&gt;. Note that any pair of variables from &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\left\{ M_{0},M_{1},M_{2}\right\} 
&lt;/script&gt;
&lt;/span&gt; are independent because they defined on mutually disjoint set of indices. Moreover, by the lemma from above, each of them if it is not a constant zero then it is distributed as &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
Bernoulli\left(0.5\right)
&lt;/script&gt;
&lt;/span&gt;. When plugging in the new notations we get&lt;span class=&quot;MathJax_Preview&quot;&gt;
&lt;script type=&quot;math/tex;mode=display&quot;&gt;
\begin{align*}
\mathbf{P}\left[X_{1}=b_{1},\:X_{2}=b_{2}\right] &amp; =\mathbf{P}\left[M_{0}+M_{1}=b_{1},\:M_{0}+M_{2}=b_{2}\right]
\end{align*}
&lt;/script&gt;
&lt;/span&gt;
Because &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
I_{1}\ne I_{2}
&lt;/script&gt;
&lt;/span&gt; there must be at most one variable from &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\left\{ M_{0},M_{1},M_{2}\right\} 
&lt;/script&gt;
&lt;/span&gt; which may be constant. Therefore, no matter which &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
M_{i}
&lt;/script&gt;
&lt;/span&gt; it is (if any), either &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
X_{1}
&lt;/script&gt;
&lt;/span&gt; or &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
X_{2}
&lt;/script&gt;
&lt;/span&gt; is a sum of two non-constant variables. W.l.o.g let it be &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
X_{1}
&lt;/script&gt;
&lt;/span&gt;, then it has the &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
M_{1}
&lt;/script&gt;
&lt;/span&gt; component which does not appear in &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
X_{2}
&lt;/script&gt;
&lt;/span&gt; and can flip the result of the sum with probability &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
0.5
&lt;/script&gt;
&lt;/span&gt; &lt;b&gt;regardless&lt;/b&gt; of what happen anywhere else, therefore &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
X_{1}
&lt;/script&gt;
&lt;/span&gt; is independent of &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
X_{2}
&lt;/script&gt;
&lt;/span&gt;, and that complete the proof.
&lt;/div&gt;
&lt;div class=&quot;Unindented&quot;&gt;

&lt;/div&gt;
&lt;div class=&quot;Indented&quot;&gt;
Last one remark. In our settings the randomized algorithm either return a solution or says “failed”, if we have a polynomial procedure to validate a solution we can generalize the settings to the case when the algorithm always output a solution, and then we verify it to determine if it is “succeeds” case of “failed” case.
&lt;/div&gt;</content><author><name>Eran Amar</name></author><category term="probability_theory" /><category term="algorithms" /><summary type="html">Warning: MathJax requires JavaScript to correctly process the mathematics on this page. Please enable JavaScript on your browser. &amp;lt;/hr&amp;gt;</summary></entry><entry><title type="html">Comparing Chernoff - Hoeffding bounds</title><link href="https://eranamar.github.io/site/2017/03/24/Comparing-Chernoff-Hoeffding-bounds.html" rel="alternate" type="text/html" title="Comparing Chernoff - Hoeffding bounds" /><published>2017-03-24T00:00:00+02:00</published><updated>2017-03-24T00:00:00+02:00</updated><id>https://eranamar.github.io/site/2017/03/24/Comparing-Chernoff---Hoeffding-bounds</id><content type="html" xml:base="https://eranamar.github.io/site/2017/03/24/Comparing-Chernoff-Hoeffding-bounds.html">&lt;script type=&quot;math/tex&quot;&gt;
\newcommand{\lyxlock}{}
&lt;/script&gt;

&lt;noscript&gt;
&lt;div class=&quot;warning&quot;&gt;
Warning: &lt;a href=&quot;http://www.mathjax.org/&quot;&gt;MathJax&lt;/a&gt; requires JavaScript to correctly process the mathematics on this page. Please enable JavaScript on your browser.
&lt;/div&gt;&lt;hr /&gt;
&amp;lt;/hr&amp;gt;&lt;/noscript&gt;

&lt;h1 class=&quot;Section&quot;&gt;
&lt;a class=&quot;toc&quot; name=&quot;toc-Section-1&quot;&gt;1&lt;/a&gt; The Definitions and Motivation
&lt;/h1&gt;
&lt;div class=&quot;Unindented&quot;&gt;
Hoeffding and Chernoff bounds (a.k.a “inequalities”) are very common &lt;i&gt;concentration measures&lt;/i&gt; that are being used in many fields in computer science. A concentration measure is a way to bound the probability of the sum of random variables to get values outside a neighborhood of the sum of their means. 
&lt;/div&gt;
&lt;div class=&quot;Indented&quot;&gt;
For example: suppose we have &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
n
&lt;/script&gt;
&lt;/span&gt; (fair) coins to toss and we want to know what is the probability that the total number of heads (i.e sum of indicators) will be “far” from half of the tosses (which is the mean of that sum), say that either &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\#heads&gt;\frac{3}{4}n
&lt;/script&gt;
&lt;/span&gt; or &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\#heads&lt;\frac{1}{4}n
&lt;/script&gt;
&lt;/span&gt;. Chernoff’s and Hoeffding’s bounds can be used to &lt;i&gt;bound&lt;/i&gt; the probability for that to happen. 
&lt;/div&gt;
&lt;div class=&quot;Indented&quot;&gt;
Both bounds are similar in their settings and their results, and sometimes it is not clear which bound is better for a given setting; maybe even both bound are equivalent. In this post we will try to get an intuition which bound is stronger (and when). 
&lt;/div&gt;
&lt;div class=&quot;Indented&quot;&gt;
Note that each of the bounds have several common variations and we will discuss only the ones which we considered “popular”. Let’s start with the first bound, a multiplicative version of Chernoff’s bound.
&lt;/div&gt;
&lt;div class=&quot;Definition&quot;&gt;
Chernoff bound. Let &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\left\{ X_{i}\right\} _{i=1}^{n}
&lt;/script&gt;
&lt;/span&gt; be independent random variables ranging in &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\left[0,1\right]
&lt;/script&gt;
&lt;/span&gt;, denote &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
X:=\sum_{i=1}^{n}X_{i}
&lt;/script&gt;
&lt;/span&gt; and let &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\mu:=\mathbb{E}\left[X\right]
&lt;/script&gt;
&lt;/span&gt;, then for any &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\epsilon\in\left(0,1\right)
&lt;/script&gt;
&lt;/span&gt; &lt;span class=&quot;MathJax_Preview&quot;&gt;
&lt;script type=&quot;math/tex;mode=display&quot;&gt;

\mathbf{P}\left[\left|X-\mu\right|&gt;\epsilon\mu\right]\le2\exp\left(-\epsilon^{2}\frac{\mu}{3}\right)

&lt;/script&gt;
&lt;/span&gt;
&lt;/div&gt;
&lt;div class=&quot;Unindented&quot;&gt;

&lt;/div&gt;
&lt;div class=&quot;Definition&quot;&gt;
Hoeffding bound. Let &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\left\{ X_{i}\right\} _{i=1}^{n}
&lt;/script&gt;
&lt;/span&gt; be independent random variables ranging in &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\left[a,b\right]
&lt;/script&gt;
&lt;/span&gt; where &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
a&lt;b
&lt;/script&gt;
&lt;/span&gt;, denote &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
X:=\sum_{i=1}^{n}X_{i}
&lt;/script&gt;
&lt;/span&gt; and let &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\mu:=\mathbb{E}\left[X\right]
&lt;/script&gt;
&lt;/span&gt;, then for any &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
t
&lt;/script&gt;
&lt;/span&gt;: &lt;span class=&quot;MathJax_Preview&quot;&gt;
&lt;script type=&quot;math/tex;mode=display&quot;&gt;

\mathbf{P}\left[\left|X-\mu\right|&gt;t\right]\le2\exp\left(\frac{-t^{2}}{n\left(b-a\right)^{2}}\right)

&lt;/script&gt;
&lt;/span&gt;
&lt;/div&gt;
&lt;div class=&quot;Unindented&quot;&gt;

&lt;/div&gt;
&lt;h1 class=&quot;Section&quot;&gt;
&lt;a class=&quot;toc&quot; name=&quot;toc-Section-2&quot;&gt;2&lt;/a&gt; Writing Hoeffding’s bound as a Chernoff’s bound 
&lt;/h1&gt;
&lt;div class=&quot;Unindented&quot;&gt;
In first glance it seems that we cannot compare between the definitions, mostly because this small technical issue: Hoeffding’s bound allows the random variables to be in any close interval &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\left[a,b\right]
&lt;/script&gt;
&lt;/span&gt; rather than &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\left[0,1\right]
&lt;/script&gt;
&lt;/span&gt;. The solution for that is to scale and shift the variables to make them takes values in &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\left[0,1\right]
&lt;/script&gt;
&lt;/span&gt;. We will start with exactly that, and them transform Hoeffding’s inequality into “Chernoff’s”.
&lt;/div&gt;
&lt;div class=&quot;Indented&quot;&gt;
So for any &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
i\in\left[n\right]
&lt;/script&gt;
&lt;/span&gt;, denote &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
Y_{i}=\frac{X_{i}}{b-a}-a
&lt;/script&gt;
&lt;/span&gt; and let &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
Y=\sum_{i=1}^{n}Y_{i}=\frac{X}{b-a}-na
&lt;/script&gt;
&lt;/span&gt;. Observe that &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\mathbb{E}\left[Y\right]=\frac{\mu}{b-a}-na
&lt;/script&gt;
&lt;/span&gt;. Clearly, now the range of &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\left\{ Y_{i}\right\} _{i=1}^{n}
&lt;/script&gt;
&lt;/span&gt; is &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\left[0,1\right]
&lt;/script&gt;
&lt;/span&gt; so we can write Hoeffding’s bound in terms of &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
Y_{i}
&lt;/script&gt;
&lt;/span&gt;’s
&lt;/div&gt;
&lt;div class=&quot;Indented&quot;&gt;
&lt;span class=&quot;MathJax_Preview&quot;&gt;
&lt;script type=&quot;math/tex;mode=display&quot;&gt;
\begin{align*}
\mathbf{P}\left[\left|X-\mu\right|&gt;t\right] &amp; =\mathbf{P}\left[\left|\frac{X}{b-a}-na-\frac{\mu}{b-a}+na\right|&gt;\frac{t}{b-a}\right]\\
 &amp; =\mathbf{P}\left[\left|Y-\mathbb{E}\left[Y\right]\right|&gt;\frac{t}{b-a}\cdot\frac{\mathbb{E}\left[Y\right]}{\mathbb{E}\left[Y\right]}\right]\\
 &amp; \le2\exp\left(\frac{-t^{2}}{\left(b-a\right)^{2}\mathbb{E}\left[Y\right]^{2}}\cdot\frac{\mathbb{E}\left[Y\right]}{3}\right)\\
 &amp; =2\exp\left(\frac{-t^{2}}{3\left(b-a\right)^{2}}\left(\frac{\mu}{b-a}-na\right)^{-1}\right)\\
 &amp; =2\exp\left(\frac{-t^{2}}{3\mu\left(b-a\right)-3a\cdot n\left(b-a\right)^{2}}\right)
\end{align*}
&lt;/script&gt;
&lt;/span&gt;
&lt;/div&gt;
&lt;div class=&quot;Indented&quot;&gt;
Where the inequality in the middle of the process is where we apply Chernoff’s bound with &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\epsilon=\frac{t}{\left(b-a\right)\mathbb{E}\left[Y\right]}
&lt;/script&gt;
&lt;/span&gt;, note that there is an implicit assumption here that &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\epsilon&lt;1
&lt;/script&gt;
&lt;/span&gt;. 
&lt;/div&gt;
&lt;div class=&quot;Indented&quot;&gt;
So we managed to formulate Hoeffding’s bound in Chernoff’s settings, ending with a very messy formula. In order to explore the behavior of the bounds further, we will simplify the analysis by adding another assumption: that &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
a=0
&lt;/script&gt;
&lt;/span&gt;.
&lt;/div&gt;
&lt;h1 class=&quot;Section&quot;&gt;
&lt;a class=&quot;toc&quot; name=&quot;toc-Section-3&quot;&gt;3&lt;/a&gt; Which bound to used?
&lt;/h1&gt;
&lt;div class=&quot;Unindented&quot;&gt;
Now we assuming that &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
a=0
&lt;/script&gt;
&lt;/span&gt;. The restriction from previous section that &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\epsilon&lt;1
&lt;/script&gt;
&lt;/span&gt; is now holds whenever &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
t&lt;\mu
&lt;/script&gt;
&lt;/span&gt;, which make sense because Chernoff’s bound, as we defined it in the beginning, only concerned with deviations that are up to &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\mu
&lt;/script&gt;
&lt;/span&gt;. 
&lt;/div&gt;
&lt;div class=&quot;Indented&quot;&gt;
Next, the term we got for Hoeffding is simplified further into &lt;span class=&quot;MathJax_Preview&quot;&gt;
&lt;script type=&quot;math/tex;mode=display&quot;&gt;

\mathbf{P}\left[\left|X-\mu\right|&gt;t\right]\le2\exp\left(\frac{-t^{2}}{3\mu b}\right)

&lt;/script&gt;
&lt;/span&gt;
Now easy to compare between the bounds. With Hoeffding we can achieve bound of &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
2\exp\left(\frac{-t^{2}}{nb^{2}}\right)
&lt;/script&gt;
&lt;/span&gt; and with Chernoff &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
2\exp\left(\frac{-t^{2}}{3\mu b}\right)
&lt;/script&gt;
&lt;/span&gt;, it just left to compare between &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
nb
&lt;/script&gt;
&lt;/span&gt; and &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
3\mu
&lt;/script&gt;
&lt;/span&gt;. If &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
nb&lt;3\mu
&lt;/script&gt;
&lt;/span&gt; then Chernoff is stronger and vise versa. We conclude that none of the bounds is always preferred upon the other (which is not so suprising), and the answer to the question “which one to use” depends on the parameters of the distribution in hand.
&lt;/div&gt;
&lt;h1 class=&quot;Section&quot;&gt;
&lt;a class=&quot;toc&quot; name=&quot;toc-Section-4&quot;&gt;4&lt;/a&gt; Chernoff bound is tight!
&lt;/h1&gt;
&lt;div class=&quot;Unindented&quot;&gt;
One suprising fact about Chernoff’s bound is that in some cases it is tight (i.e. gives a lower bound). The theorem below is taken from those &lt;a class=&quot;URL&quot; href=&quot;https://ece.uwaterloo.ca/~nmousavi/Papers/Chernoff-Tightness.pdf&quot;&gt;notes&lt;/a&gt; (see the link for the full proof).
&lt;/div&gt;
&lt;div class=&quot;Theorem&quot;&gt;
Let &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\left\{ X_{i}\right\} _{i=1}^{n}
&lt;/script&gt;
&lt;/span&gt; be i.i.d random variables ranging in &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\left\{ 0,1\right\} 
&lt;/script&gt;
&lt;/span&gt; with &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\mathbf{P}\left[X_{i}=1\right]=p
&lt;/script&gt;
&lt;/span&gt;, denote &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
X:=\sum_{i=1}^{n}X_{i}
&lt;/script&gt;
&lt;/span&gt; and let &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\mu:=\mathbb{E}\left[X\right]=np
&lt;/script&gt;
&lt;/span&gt;. &lt;br /&gt;
If &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
p\le\frac{1}{4}
&lt;/script&gt;
&lt;/span&gt;, then for any &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
t&gt;0
&lt;/script&gt;
&lt;/span&gt; &lt;span class=&quot;MathJax_Preview&quot;&gt;
&lt;script type=&quot;math/tex;mode=display&quot;&gt;

\mathbf{P}\left[X-\mu&gt;t\right]\ge\frac{1}{4}\exp\left(-t^{2}\frac{2}{\mu}\right)

&lt;/script&gt;
&lt;/span&gt;
If &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
p&lt;\frac{1}{2}
&lt;/script&gt;
&lt;/span&gt;, then for any &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
t\in\left[0,n\left(1-2p\right)\right]
&lt;/script&gt;
&lt;/span&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;
&lt;script type=&quot;math/tex;mode=display&quot;&gt;

\mathbf{P}\left[X-\mu&gt;t\right]\ge\frac{1}{4}\exp\left(-t^{2}\frac{2}{\mu}\right)

&lt;/script&gt;
&lt;/span&gt;
&lt;br /&gt;&lt;/div&gt;
&lt;div class=&quot;Unindented&quot;&gt;

&lt;/div&gt;
&lt;div class=&quot;Indented&quot;&gt;
Note the differences between that regime and the one from the definition at the beginning of the post: in this theorem the variables are i.i.d (rather than only independent) and they are discrete.
&lt;/div&gt;</content><author><name>Eran Amar</name></author><category term="probability_theory" /><summary type="html">Warning: MathJax requires JavaScript to correctly process the mathematics on this page. Please enable JavaScript on your browser. &amp;lt;/hr&amp;gt;</summary></entry><entry><title type="html">Introduction to Hypergraphs</title><link href="https://eranamar.github.io/site/2017/03/16/Introduction-to-Hypergraphs.html" rel="alternate" type="text/html" title="Introduction to Hypergraphs" /><published>2017-03-16T00:00:00+02:00</published><updated>2017-03-16T00:00:00+02:00</updated><id>https://eranamar.github.io/site/2017/03/16/Introduction-to-Hypergraphs</id><content type="html" xml:base="https://eranamar.github.io/site/2017/03/16/Introduction-to-Hypergraphs.html">&lt;script type=&quot;math/tex&quot;&gt;
\newcommand{\lyxlock}{}
&lt;/script&gt;

&lt;noscript&gt;
&lt;div class=&quot;warning&quot;&gt;
Warning: &lt;a href=&quot;http://www.mathjax.org/&quot;&gt;MathJax&lt;/a&gt; requires JavaScript to correctly process the mathematics on this page. Please enable JavaScript on your browser.
&lt;/div&gt;&lt;hr /&gt;
&amp;lt;/hr&amp;gt;&lt;/noscript&gt;

&lt;div class=&quot;Unindented&quot;&gt;
In this post, I will review some of the basic definitions about hypergraphs and sparsifiers on them. I will start from the very basic definitions about Graphs, then generalizing them to Hypergraphs. Later, I will present the definition of cuts sparsifiers and some lower bound related to them.
&lt;/div&gt;
&lt;h1 class=&quot;Section&quot;&gt;
&lt;a class=&quot;toc&quot; name=&quot;toc-Section-1&quot;&gt;1&lt;/a&gt; Basic definitions in Graphs
&lt;/h1&gt;
&lt;div class=&quot;Unindented&quot;&gt;
Let’s start from the very beginning - graphs. Graphs are fundamental objects in computer science, and they are used to model relations between objects. Formally, a &lt;i&gt;graph&lt;/i&gt; &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
G=\left(V,E,w\right)
&lt;/script&gt;
&lt;/span&gt; is a tuple of two sets, &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
V
&lt;/script&gt;
&lt;/span&gt; and &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
E
&lt;/script&gt;
&lt;/span&gt; and a function &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
w
&lt;/script&gt;
&lt;/span&gt;. &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
V
&lt;/script&gt;
&lt;/span&gt; is the set of &lt;i&gt;vertices&lt;/i&gt; (i.e. the elements), usually denoted as &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\left[n\right]:=\left\{ 1,2,..,n\right\} 
&lt;/script&gt;
&lt;/span&gt;, and &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
E
&lt;/script&gt;
&lt;/span&gt; is a set of &lt;i&gt;edges&lt;/i&gt; between those vertices (i.e. indicating which elements belongs to the relation the graph represents). An edge is just a set of two vertices, that is &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
e=\left\{ u,v\right\} \in E\subseteq\left\{ A\mid A\subseteq V,\:\:\left|A\right|=2\right\} 
&lt;/script&gt;
&lt;/span&gt;. The function &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
w:\:E\rightarrow\mathbb{R}_{\ge0}
&lt;/script&gt;
&lt;/span&gt; assign non-negative weight for each edge in the graph, and called weight function. For instance, we can model friendships in Facebook as a graph, the vertices will be all the users in Facebook, and there will be an edge between any pair of useres if they are “friends” of each other.
&lt;/div&gt;
&lt;div class=&quot;Indented&quot;&gt;
A &lt;i&gt;cut&lt;/i&gt; in a graph &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
G
&lt;/script&gt;
&lt;/span&gt; is a partition of &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
V
&lt;/script&gt;
&lt;/span&gt; into two sets, &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\left(S,V\backslash S\right)
&lt;/script&gt;
&lt;/span&gt;. We say that an edge &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
e=\left\{ u,v\right\} 
&lt;/script&gt;
&lt;/span&gt; &lt;i&gt;cross&lt;/i&gt; the cut defined by &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
S
&lt;/script&gt;
&lt;/span&gt; if and only if &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
S\cap e\ne\emptyset
&lt;/script&gt;
&lt;/span&gt; and &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\left(V\backslash S\right)\cap e\ne\emptyset
&lt;/script&gt;
&lt;/span&gt;. Now we can talk about the &lt;i&gt;weight of the cut&lt;/i&gt;, that is, if we have a cut that is defined by &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
S
&lt;/script&gt;
&lt;/span&gt; and a weight function &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
w
&lt;/script&gt;
&lt;/span&gt; then, &lt;span class=&quot;MathJax_Preview&quot;&gt;
&lt;script type=&quot;math/tex;mode=display&quot;&gt;

w_{G}\left(S\right)=\sum_{\begin{array}{c}
e\in E\\
e\cap S\notin\{\emptyset,e\}
\end{array}}w(e)

&lt;/script&gt;
&lt;/span&gt;
in words, the weight of a cut is the sum of weights of all edges that cross it.
&lt;/div&gt;
&lt;h1 class=&quot;Section&quot;&gt;
&lt;a class=&quot;toc&quot; name=&quot;toc-Section-2&quot;&gt;2&lt;/a&gt; Generalizing to Hyper-Graphs
&lt;/h1&gt;
&lt;div class=&quot;Unindented&quot;&gt;
The model of a graph, as defined above, can’t be used to describe non binary relationships. For example, say we want to model Facebook groups via a graph; the only way to do so is by including in the set of vertices also all the Facebook groups and then connecting each user to all its groups with edges. The main limitation here is that the vertices have more than one meaning (they can describe both &lt;i&gt;users&lt;/i&gt; and &lt;i&gt;groups&lt;/i&gt;). In order to avoid such ambiguity we can use a richer model, we can use Hypergraphs.
&lt;/div&gt;
&lt;div class=&quot;Indented&quot;&gt;
Hypergraphs are generalization of graphs in the sense that edges may be of arbitrary size. Meaning that now &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
E\subseteq2^{V}\backslash\emptyset=\left\{ A\mid A\subseteq V,\:\:\left|A\right|&gt;0\right\} 
&lt;/script&gt;
&lt;/span&gt;. Going back to our example, we can model Facebook groups by the graph &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\left(V,E\right)
&lt;/script&gt;
&lt;/span&gt; when &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
V
&lt;/script&gt;
&lt;/span&gt; is the set of all users, and any group in Facebook will be an edge &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
e\in2^{V}
&lt;/script&gt;
&lt;/span&gt; such that &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
e
&lt;/script&gt;
&lt;/span&gt; contains the users belongs to that group. More mathematical example will be &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
G=\left(\left[5\right],\left\{ \left\{ 4\right\} ,\left\{ 1,2,5\right\} \right\} \right)
&lt;/script&gt;
&lt;/span&gt;, which is a valid hypergraph with two edges: &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\left\{ 4\right\} 
&lt;/script&gt;
&lt;/span&gt; and &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\left\{ 1,2,5\right\} 
&lt;/script&gt;
&lt;/span&gt;. 
&lt;/div&gt;
&lt;div class=&quot;Indented&quot;&gt;
Note that the definition of &lt;i&gt;cuts&lt;/i&gt; and &lt;i&gt;cut weight&lt;/i&gt; can be transfer easily into hypergraphs because they stay the same as with regular graphs. Usually we will be interested in family of hypergraphs with limited size, that is, hypergraphs where each edge is of size at most &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
r
&lt;/script&gt;
&lt;/span&gt;. Such hypergraphs are said to be &lt;i&gt;r-uniform&lt;/i&gt;.
&lt;/div&gt;
&lt;h1 class=&quot;Section&quot;&gt;
&lt;a class=&quot;toc&quot; name=&quot;toc-Section-3&quot;&gt;3&lt;/a&gt; Cuts Sparsification 
&lt;/h1&gt;
&lt;div class=&quot;Unindented&quot;&gt;
Let &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\epsilon\in\left(0,1\right)
&lt;/script&gt;
&lt;/span&gt;. Given a hypergraph &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
H=\left(V,E\right)
&lt;/script&gt;
&lt;/span&gt; and a weight function &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
w
&lt;/script&gt;
&lt;/span&gt;, we say that a hypergraph &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
K=\left(V,E_{\epsilon},w\right)
&lt;/script&gt;
&lt;/span&gt; is &lt;i&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\epsilon
&lt;/script&gt;
&lt;/span&gt;-cut-sparsifier&lt;/i&gt; of &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
H
&lt;/script&gt;
&lt;/span&gt; if &lt;i&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;
&lt;script type=&quot;math/tex;mode=display&quot;&gt;

\forall S\subset V\qquad(1-\epsilon)\cdot w_{H}(S)\le w_{K}(S)\le(1+\epsilon)\cdot w_{H}(S)

&lt;/script&gt;
&lt;/span&gt;
&lt;/i&gt;and the set &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
E_{\epsilon}
&lt;/script&gt;
&lt;/span&gt; may be any set in &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
2^{V}\backslash\emptyset
&lt;/script&gt;
&lt;/span&gt;.
&lt;/div&gt;
&lt;div class=&quot;Indented&quot;&gt;
It is not part of the definition, but the goal is to find cut-sparsifier that shrink the number of edges, that is, with the smallest &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\left|E_{\epsilon}\right|
&lt;/script&gt;
&lt;/span&gt; possible. Whereas in regular graphs it is understood that we want to minimize the &lt;b&gt;number&lt;/b&gt; of edges, in hypergraphs we should also consider the &lt;b&gt;size&lt;/b&gt; of the edges in &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
E_{\epsilon}
&lt;/script&gt;
&lt;/span&gt;. That is, the quality of the sparsifier will be measure also with respect to the size of the edges in the resulting graph. For that we introduce the &lt;i&gt;total edge size&lt;/i&gt; of a hypergraph which is &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\sum_{e\in E_{\epsilon}}\left|e\right|
&lt;/script&gt;
&lt;/span&gt;.
&lt;/div&gt;
&lt;h1 class=&quot;Section&quot;&gt;
&lt;a class=&quot;toc&quot; name=&quot;toc-Section-4&quot;&gt;4&lt;/a&gt; Upper &amp;amp; Lower Bounds for Sparsification
&lt;/h1&gt;
&lt;div class=&quot;Unindented&quot;&gt;
For regular graphs, we&lt;a class=&quot;URL&quot; href=&quot;http://dx.doi.org/10.1016/j.jpdc.2009.04.011&quot;&gt; already know&lt;/a&gt; how to reduce the number of edges to be &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\mathcal{O}\left(n/\epsilon^{2}\right)
&lt;/script&gt;
&lt;/span&gt; for any &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\epsilon\in\left(0,1\right)
&lt;/script&gt;
&lt;/span&gt;. That is surprising, because no matter how many edges there are in the original graph, which can be up to &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
n^{2}
&lt;/script&gt;
&lt;/span&gt;, there is an algorithms that can reduce the number of edges to &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\mathcal{O}\left(n/\epsilon^{2}\right)
&lt;/script&gt;
&lt;/span&gt;, while maintaining approximately the same weights for all possible cuts in the graph. Moreover, that algorithm find the cut-sparsifier in polynomial time. 
&lt;/div&gt;
&lt;div class=&quot;Indented&quot;&gt;
Later results show that this upper bound is also a lower bound, that is, there are graphs that cannot be reduced into less that &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
\mathcal{O}\left(n/\epsilon^{2}\right)
&lt;/script&gt;
&lt;/span&gt; edges.
&lt;/div&gt;
&lt;div class=&quot;Indented&quot;&gt;
However, when working with hypergraphs it is not quite clear if one can reduce the total edges size of the graph to be even order of &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
n^{2}
&lt;/script&gt;
&lt;/span&gt;. Think about it, potentially the number of edges in a hypergraph can be &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
2^{n}
&lt;/script&gt;
&lt;/span&gt;, so &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
n^{2}
&lt;/script&gt;
&lt;/span&gt; can be considered quite small for such hypergraphs. 
&lt;/div&gt;
&lt;div class=&quot;Indented&quot;&gt;
An interesting&lt;a class=&quot;URL&quot; href=&quot;https://arxiv.org/abs/1409.2391&quot;&gt; result from 2015&lt;/a&gt;, showed lower bound of &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
O(\epsilon^{-2}n\cdot r)
&lt;/script&gt;
&lt;/span&gt; edges for &lt;i&gt;r-&lt;/i&gt;uniform hypergraphs (assuming that &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
r&gt;\log\left(n\right)
&lt;/script&gt;
&lt;/span&gt;), which, when converting to total edges size is actually &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;
O(\epsilon^{-2}n\cdot r^{2})
&lt;/script&gt;
&lt;/span&gt;. 
&lt;/div&gt;
&lt;div class=&quot;Indented&quot;&gt;
The question that one can ask now is, can we do better? Is there an algorithm that can construct a cut-sparsifier for hypergraphs with &lt;i&gt;smaller&lt;/i&gt; total edges size?
&lt;/div&gt;
&lt;div class=&quot;Indented&quot;&gt;
That is, actually, an open question which is studied nowdays.
&lt;/div&gt;</content><author><name>Eran Amar</name></author><category term="hypergraphs" /><category term="cuts_sparsifier" /><summary type="html">Warning: MathJax requires JavaScript to correctly process the mathematics on this page. Please enable JavaScript on your browser. &amp;lt;/hr&amp;gt;</summary></entry></feed>